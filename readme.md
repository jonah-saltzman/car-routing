# Perceptive Automata Challenge Write-Up
## Jonah Saltzman

### `Car` class

I have included two solutions to this coding challenge: `routing-naive.py` and `routing-alg-fast.py`. The solutions are identical except for the `get_routes` function; both make use of a `Car` class, which takes a `board` variable, an x and y starting position, and optionally, lists containing the car’s initial riders and requests that it should have at the start of the program. The class has some methods that are used throughout the rest of the program, including `Car.pos()` which returns the car’s current position as a list in the format [x-position, y-position], `Car.add_request()`, which takes a single request and adds it to the car’s pending requests, `Car.exchange()`, which checks whether any pending requests’ start positions, or current riders’ destinations, are at the car’s current position, and if so, it exchanges those riders and returns two lists, `pickups` and `dropoffs`, and `Car.done()`, which returns True if the car has no riders or pending requests, otherwise False.

### `Car.move()`
Most importantly, the Car class has a `Car.move()` method, which is where my two solutions differ. `Car.move` decides in which direction the car should move, and makes that move by changing its `self.x` and `self.y` properties. In the “naive” solution, `Car.move` checks if the car has any riders or pending requests; if it does not, it moves toward the center of the board. If it does, it calls `get_routes`, which takes the lists of the car’s riders and pending requests as arguments, and combines the riders’ destinations and the requests’ starts into a single list and returns that list. This list is then passed to `shortest_route`, which prepends the car’s current position to each destination, calculates the distance between the two points, and returns the route with the shortest distance. Thus, in my naive solution, the car chooses where to go simply by picking the closest destination among all its riders’ destinations and requests’ start points.

### Algorithmic solution
From my experience writing a solver algorithm for a 5x5 version of tic-tac-toe, I had a feeling that I could do better than this solution. There will be plenty of cases where the route consisting of choosing the next closest stop over and over again will be longer than necessary. A smarter solution would analyze many possible routes, with many different first destinations, and choose the best one. In my first attempt at a better solution, `get_routes` similarly combined the riders’ end points and requests’ start points into a single list, and then called `permute` on that list, which generated all possible permutations of the list of destinations, passed those destinations to a modified `shortest_route` function that calculated the length of each entire route and picked the shortest one. There were two major problems with this solution: first, by not including pending requests’ endpoints in the permutations, my program was ignoring crucial information that would have a significant impact on which route permutation would actually be the shortest; and second, it got very slow very quickly as the number of requests increased. 

### Data structures
In order to solve the first problem, instead of passing only the requests’ start positions to the permute function, I changed the structure of the data being passed to dictionaries, and instead of passing destinations as lists in the [x, y] format, passed riders’ destinations as “generic” destinations in the format `{ dest: [x, y] }`, and passed requests as start-end pairs in the format `{ start: [x, y], end: [x, y] }`. Initially, the permute function worked by iterating through each [x, y] pair in the list, taking the current pair out of the list, recursively permuting the remaining part of the list, then prepending the removed pair to the beginning of the permuted list. In the version permuting lists of dictionaries instead of lists of lists, the function checks whether the removed dictionary element is a generic { dest: [x, y] } dict or a start-end pair. If it is a start end pair, it converts the start and end properties to their own { dest: [x, y] } dictionary, places the end dict into the list of dictionaries about to be permuted, and uses the start dict as the element to be prepended to the permuted list. This guarantees that for every start-end pair, the start destination will always come before the end destination in every permutation of the given list, while allowing requests’ endpoints to be included when comparing routes’ distances.

### Optimization
To solve the second problem, of how long the algorithm took to produce permutations of many destinations, I was inspired by the alpha-beta pruning method I learned when writing my 5x5 tic-tac-toe algorithm. In a 2-player, zero-sum game like tic-tac-toe (or chess), an algorithm can check every possible move for one player, then check all the possible moves the other player could make in response, and go back and forth like that until it finds the end of a game, and assign that path in the decision tree a score according to the outcome - positive scores for wins for the side the algorithm is playing for, and negative scores for opponent wins. It then chooses a move for the current board state according to whether and how quickly that move will lead to a win. In chess, or even 5x5 tic-tac-toe, the number of possible games quickly becomes too large to analyze in a reasonable amount of time. Thus, alpha-beta pruning can be implemented: for whichever player for which the algorithm is checking a move, if the potential score of that move is already worse than the worst final score already encountered for that player, the algorithm can prune that “branch” from the decision tree. With this car problem, even though there are not two “players”, I thought a similar approach could be used to help reduce the number of route permutations the algorithm had to check before coming to a decision.


I implemented this approach by defining a global variable, `best`, as positive infinity. As the permutation algorithm recursively calls itself, it keeps track of the part of the route that has already been “determined” in that branch of the permutation tree. If there are 4 destinations in a route, `[a, b, c, d]`, the second iteration of the loop in the first call to `permute` would select [b] as the new first element, before recursively calling `permute` on `[a, c, d]`. However, it would also pass `[b]` to the next call of permute, as the `start` variable. Then, on the second loop of the next recursive call, [c] would be removed from the [a, c, d] list, and [b, c] would comprise the next `start` variable, and so on. This means that for every base case, where the length of the list to be permuted equals 1, the function can use the `start` list to determine whether that base case constitutes a full route (whether the `start` list plus the base case is equal to the number of destinations a full-length route will contain). If it does, it calculates the length of that full route with `route_length`; if this length is better (smaller) than the `best` global variable, it is stored in the `best` variable. Thus, `best` tracks the length of the shortest full route already encountered by the algorithm at any point in its recursion. In another part of `permute`, where each new “first” destination is removed from the remaining list to be placed at the beginning of the list before permuting, before the function recursively calls itself, it adds the new “first” element to the existing `stops` list it was passed by the previous call, and calculates the length of that partial route. If that partial route is already longer than the `best` route previously encountered, the current recursive branch can be “pruned” - we already know that this route will not be the best, and any further recursion/permutation is unnecessary. A simple `continue` skips to the next iteration of the function. The other very important optimization was changing the Car class to remember its current destination, and to not recalculate the route if no pickups, dropoffs, or new requests have occurred. 

### Improvements
The above optimizations produced dramatic improvements, in time required for the calculations compared to my initial algorithmic solution, and in the actual length of the route required to complete all riders’ requests compared to my naive solution. On a 100x100 board, my solutions achieved the following results with 7 requests:

| Solution            | Computation Time | Route Length |
|---------------------|------------------|--------------|
| Naive               | 0.03 seconds     | 426 ticks    |
| Alg (not optimized) | 95.28 seconds    | 364 ticks    |
| Alg (optimized)     | 0.12 seconds     | 359 ticks    |

### Time Complexity
The time complexity of the naive solution is O(2n), where n is the number of pending requests plus the number of riders in the car. Each request’s pickup location and each rider’s dropoff location is normalized into a list of `[x, y]` lists, each of which has its distance from the car’s current position calculated - this is the first half of the 2n. Then, in order to pick the shortest route, each route (consisting of the car’s location and the normalized destination) is iterated through again, comparing its length with the shortest length seen so far. Thus, the time complexity is O(2n).

The time complexity of a general permutation algorithm is O(n * n!), where n is the number of elements to be permuted. Thus, if we keep n as the number of pending requests plus the number of riders in the car, in O(n * n!), n is actually (a + 2b), where a is the number of riders in the car, and b is the number of pending requests, since each pending request will be separated out into two different elements that will be permuted separately. So for the permutation algorithm, the time complexity is 

    O((a + 2b) * (a + 2b)!)

While if we keep the same a and b variables for the naive solution, it will have a time complexity of

	O(2(a + b)) = O(2a + 2b)

So, the time complexity of the permutation algorithm is much, much bigger than that of the naive solution. However, although the upper bound of the time complexity of the optimized and non-optimized permutation algorithm should be the same, in practice, the optimized version is much faster because some iterations are skipped (branches are pruned), but which ones will be skipped cannot be known in advance. In addition, which branches will be pruned is heavily dependent on the order in which the elements to be permuted are passed to the `permute` function. If a very short route is discovered early on in the recursion, many branches will be pruned, but if the same route is not discovered until closer to the end of the recursion, branches that would have been pruned will already have been processed fully, and less benefit will be gained from the optimization. So, a further optimization to my solution would be to write a pre-algorithm sorter that could efficiently sort destinations in such a way that the permute function would encounter a short route early in its recursion.
